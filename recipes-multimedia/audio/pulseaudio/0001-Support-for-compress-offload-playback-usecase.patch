From 5781b8d65f8eeb0a4668bae12b854060b8b55d09 Mon Sep 17 00:00:00 2001
From: Puneeth Prabhu <quic_pprabh@quicinc.com>
Date: Mon, 8 May 2023 11:07:17 +0800
Subject: [PATCH 1/6] Support for compress offload playback usecase

* Infrastructure to add support for playing back compressed data.
* A new set_format() method on sinks to configure for a specific
  compressed format
* Helper functions to distinguish between PCM/passthrough/compressed
  use-cases
* Moving to calling passthrough/compressed mode as "exclusive" mode to
  represent the idea that the sink is exclusive to the single
  sink-input connected to it
* An implicit assumption that sinks can skip rendering data in IDLE
  for compressed mode
* Adds IEC61937 format definition in PA core
* Expose a flush method for compressed streams. For compressed streams,
  it is not expected that sinks will be able to
  rewind. Instead, when a stream is being flushed, the expectation is that
  the sink should also do the same (discarding any buffered compressed
  data as well as decoded data that has not yet been rendered).
* Add a drain method for compressed streams. We cannot simple complete a
  drain as we do with PCM streams for compressed streams as there might be
  a fair amount of data buffered in the compressed sink. To account for this,
  we add an *asynchronous* drain method on the sink. This should trigger a drain,
  and on completion, the sink should call pa_sink_drain_complete() which in turn
  will notify the stream that the drain was actually completed.
* format: Add a format for MPEG and AAC data
* format: Add new API to check if a format is passthrough. This will be needed when
  adding non-passthrough compressed format, at which point !pa_format_info_pcm() may not
  necessarily signify a passthrough format.
* Support raw MP3 data (MPEG-1 or MPEG-2, layer 3).
* the assumption is that most decoders don't really care * support
  between MPEG-2 and MPEG-4 AAC data. Clients will likely need to
  add some things to the pa_format_info proplist to make this usable:
  * MPEG-2 vs. MPEG-4 AAC (for decoders that care)
  * Stream format (raw vs. ADTS vs. LOAS)
  * AudioSpecificConfig to signal AudioObjectType and any other params
* Support get time for compressed stream. Cannot use bytes-to-time conversion
  for compressed streams. so return the pal sess_time to provide client sink's
  time. the sink_sess_usec is 0 by default.
* pacat: Allow specifying non-PCM encoding. Add --encoding argument to allow
  specifying a non-PCM format. This is expected to be useful for testing support
  for compressed formats.
* pacat: allow specifying stream format. Add --stream-format argument to allow
  specifying a stream format. This is expected to be useful for testing support
  for compressed formats, like AAC.
* pacat: Enable the function of cache trailing partial frames for paplay compress
  offload playabck. Need cache any trailing partial frames if the STDIN read system call
  return a length that isn't in multiples of the stream's sample-spec frame size to
  avoid invalid writes of the PA stream.
* Changes to enable compress volume change support via pulseaudio.

Upstream-Status: Pending
Signed-off-by: Raveendranath Kondrakunta <quic_rkondrak@quicinc.com>
Signed-off-by: Yuchao Pan <quic_yuchpan@quicinc.com>
Signed-off-by: Pratyush Meduri <quic_mpratyus@quicinc.com>
Signed-off-by: SaiRamReddy Bojja <quic_sbojja@quicinc.com>
Signed-off-by: leqi <quic_leqi@quicinc.com>
---
 src/meson.build                 |   1 +
 src/modules/alsa/alsa-sink.c    |   2 +-
 src/pulse/def.h                 |   3 +
 src/pulse/format.c              |  48 +++++++
 src/pulse/format.h              |  42 ++++++
 src/pulse/map-file              |   2 +
 src/pulse/meson.build           |   2 +-
 src/pulse/stream.c              |  23 ++-
 src/pulsecore/core-format.c     |  23 ++-
 src/pulsecore/memchunk.h        |   1 +
 src/pulsecore/meson.build       |  47 ++-----
 src/pulsecore/protocol-native.c |  76 +++++++++-
 src/pulsecore/rtpoll.c          |   7 +-
 src/pulsecore/sink-input.c      |  98 +++++++++++--
 src/pulsecore/sink-input.h      |  12 ++
 src/pulsecore/sink.c            |  98 +++++++++++--
 src/pulsecore/sink.h            |  35 ++++-
 src/pulsecore/source-output.c   |   4 +-
 src/pulsecore/source.c          |   4 +-
 src/pulsecore/tinymp3.h         | 109 +++++++++++++++
 src/utils/pacat.c               | 241 ++++++++++++++++++++++++++++++--
 21 files changed, 782 insertions(+), 96 deletions(-)
 create mode 100644 src/pulsecore/tinymp3.h

diff --git a/src/meson.build b/src/meson.build
index e2860811b..75e51988e 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -143,6 +143,7 @@ libpulsecommon_headers = [
   'pulsecore/thread.h',
   'pulsecore/time-smoother.h',
   'pulsecore/time-smoother_2.h',
+  'pulsecore/tinymp3.h',
   'pulsecore/tokenizer.h',
   'pulsecore/usergroup.h',
   'pulsecore/sndfile-util.h',
diff --git a/src/modules/alsa/alsa-sink.c b/src/modules/alsa/alsa-sink.c
index 76a710e04..0d23722da 100644
--- a/src/modules/alsa/alsa-sink.c
+++ b/src/modules/alsa/alsa-sink.c
@@ -1164,7 +1164,7 @@ static int unsuspend(struct userdata *u, bool recovering) {
 
     pa_log_info("Trying resume...");
 
-    if ((is_iec958(u) || is_hdmi(u)) && pa_sink_is_passthrough(u->sink)) {
+    if ((is_iec958(u) || is_hdmi(u)) && pa_sink_is_exclusive(u->sink)) {
         /* Need to open device in NONAUDIO mode */
         int len = strlen(u->device_name) + 8;
 
diff --git a/src/pulse/def.h b/src/pulse/def.h
index 4097bd89c..a400ffcf8 100644
--- a/src/pulse/def.h
+++ b/src/pulse/def.h
@@ -694,6 +694,9 @@ typedef struct pa_timing_info {
      * playback streams and record streams connected to a monitor
      * source. */
 
+    pa_usec_t sink_sess_usec;
+    /** Value of the current sink session time. */
+
     pa_usec_t source_usec;
     /**< Time in usecs a sample takes from being recorded to being
      * delivered to the application. Only for record streams. */
diff --git a/src/pulse/format.c b/src/pulse/format.c
index 00bae2d46..39180b84b 100644
--- a/src/pulse/format.c
+++ b/src/pulse/format.c
@@ -49,6 +49,13 @@ static const char* const _encoding_str_table[]= {
     [PA_ENCODING_MPEG2_AAC_IEC61937] = "mpeg2-aac-iec61937",
     [PA_ENCODING_TRUEHD_IEC61937] = "truehd-iec61937",
     [PA_ENCODING_DTSHD_IEC61937] = "dtshd-iec61937",
+    [PA_ENCODING_UNKNOWN_IEC61937] = "unknown-iec61937",
+    [PA_ENCODING_UNKNOWN_4X_IEC61937] = "unknown-4x-iec61937",
+    [PA_ENCODING_UNKNOWN_HBR_IEC61937] = "unknown-hbr-iec61937",
+    [PA_ENCODING_MAT_IEC61937] = "mat-iec61937",
+    [PA_ENCODING_MPEG] = "mpeg",
+    [PA_ENCODING_AAC] = "aac",
+    [PA_ENCODING_DSD] = "dsd",
     [PA_ENCODING_ANY] = "any",
 };
 
@@ -110,6 +117,47 @@ int pa_format_info_is_pcm(const pa_format_info *f) {
     return f->encoding == PA_ENCODING_PCM;
 }
 
+int pa_format_info_is_passthrough(const pa_format_info *f) {
+    switch (f->encoding) {
+        case PA_ENCODING_AC3_IEC61937:
+        case PA_ENCODING_EAC3_IEC61937:
+        case PA_ENCODING_MPEG_IEC61937:
+        case PA_ENCODING_DTS_IEC61937:
+        case PA_ENCODING_MPEG2_AAC_IEC61937:
+        case PA_ENCODING_TRUEHD_IEC61937:
+        case PA_ENCODING_UNKNOWN_IEC61937:
+        case PA_ENCODING_UNKNOWN_4X_IEC61937:
+        case PA_ENCODING_UNKNOWN_HBR_IEC61937:
+        case PA_ENCODING_MAT_IEC61937:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+int pa_format_info_is_compressed(const pa_format_info *f) {
+    switch (f->encoding) {
+        case PA_ENCODING_MPEG:
+        case PA_ENCODING_AAC:
+        case PA_ENCODING_DSD:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+int pa_format_info_is_compressed_capture(const pa_format_info *f) {
+        switch (f->encoding) {
+        case PA_ENCODING_DSD:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
 char *pa_format_info_snprint(char *s, size_t l, const pa_format_info *f) {
     char *tmp;
 
diff --git a/src/pulse/format.h b/src/pulse/format.h
index 5f97929c2..bc97c6ae8 100644
--- a/src/pulse/format.h
+++ b/src/pulse/format.h
@@ -62,10 +62,33 @@ typedef enum pa_encoding {
     PA_ENCODING_DTSHD_IEC61937,
     /**< DTS-HD Master Audio encapsulated in IEC 61937 header/padding. \since 13.0 */
 
+    PA_ENCODING_UNKNOWN_IEC61937,
+    /**< Data with an unknown encoding in IEC 61937 header/padding. Required device rate is assumed to be same as the media
+     * sample rate. \since 13.0 */
+
+    PA_ENCODING_UNKNOWN_4X_IEC61937,
+    /**< Data with an unknown encoding in IEC 61937 header/padding. Required device rate is assumed to be four times the media
+     * sample rate. \since 13.0 */
+
+    PA_ENCODING_UNKNOWN_HBR_IEC61937,
+    /**< High bitrate data with an unknown encoding in IEC 61937 header/padding. \since 13.0 */
+
+    PA_ENCODING_MAT_IEC61937,
+    /**< Dolby MAT data encapsulated in IEC 61937 header/padding. */
+
     /* Remeber to update
      * https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/SupportedAudioFormats/
      * when adding new encodings! */
 
+    PA_ENCODING_MPEG,
+    /**< MPEG-1 or MPEG-2 (Part 3, not AAC) data. \since: FIXME */
+
+    PA_ENCODING_AAC,
+    /**< MPEG-2 or MPEG-4 AAC data. \since: FIXME */
+
+    PA_ENCODING_DSD,
+    /**< DSD data. \since: FIXME */
+
     PA_ENCODING_MAX,
     /**< Valid encoding types must be less than this value */
 
@@ -83,6 +106,8 @@ typedef enum pa_encoding {
 #define PA_ENCODING_MPEG2_AAC_IEC61937 PA_ENCODING_MPEG2_AAC_IEC61937
 #define PA_ENCODING_TRUEHD_IEC61937 PA_ENCODING_TRUEHD_IEC61937
 #define PA_ENCODING_DTSHD_IEC61937 PA_ENCODING_DTSHD_IEC61937
+#define PA_ENCODING_MPEG PA_ENCODING_MPEG
+#define PA_ENCODING_AAC PA_ENCODING_AAC
 #define PA_ENCODING_MAX PA_ENCODING_MAX
 #define PA_ENCODING_INVALID PA_ENCODING_INVALID
 /** \endcond */
@@ -120,6 +145,23 @@ int pa_format_info_valid(const pa_format_info *f);
  * (i.e.\ uncompressed data) format. \since 1.0 */
 int pa_format_info_is_pcm(const pa_format_info *f);
 
+/** Returns non-zero when the format info structure represents a compressed
+ * format which can be transmitted as a PCM-equivalent format. This primarily
+ * applies to IEC61937-encapsulated formats. \since FIXME */
+int pa_format_info_is_passthrough(const pa_format_info *f);
+
+/** Returns non-zero when the format info structure represents a compressed
+ * format which cannot be transmitted as a PCM-equivalent format. This applies
+ * to most compressed data except when encapsulated in the IEC61937 format.
+ * \since FIXME. */
+int pa_format_info_is_compressed(const pa_format_info *f);
+
+/** Returns non-zero when the format info structure represents a compressed
+ * format which cannot be transmitted as a PCM-equivalent format. This applies
+ * to most compressed data except when encapsulated in the IEC61937 format.
+ * \since FIXME. */
+int pa_format_info_is_compressed_capture(const pa_format_info *f);
+
 /** Returns non-zero if the format represented by \a first is a subset of
  * the format represented by \a second. This means that \a second must
  * have all the fields that \a first does, but the reverse need not
diff --git a/src/pulse/map-file b/src/pulse/map-file
index 3df03cdd3..99eb1f106 100644
--- a/src/pulse/map-file
+++ b/src/pulse/map-file
@@ -190,6 +190,8 @@ pa_format_info_get_prop_type;
 pa_format_info_get_rate;
 pa_format_info_get_sample_format;
 pa_format_info_is_compatible;
+pa_format_info_is_passthrough;
+pa_format_info_is_compressed;
 pa_format_info_is_pcm;
 pa_format_info_new;
 pa_format_info_set_channel_map;
diff --git a/src/pulse/meson.build b/src/pulse/meson.build
index c2128e087..941f8c30f 100644
--- a/src/pulse/meson.build
+++ b/src/pulse/meson.build
@@ -92,7 +92,7 @@ libpulse_dep = declare_dependency(link_with: libpulse)
 
 install_headers(
   libpulse_headers, 'simple.h',
-  subdir : 'pulse'
+  install_dir : join_paths(includedir, 'pulse')
 )
 
 libpulse_simple = shared_library('pulse-simple',
diff --git a/src/pulse/stream.c b/src/pulse/stream.c
index f0c8034a4..39630f58b 100644
--- a/src/pulse/stream.c
+++ b/src/pulse/stream.c
@@ -51,6 +51,7 @@
 #define SMOOTHER_ADJUST_TIME (1000*PA_USEC_PER_MSEC)
 #define SMOOTHER_MIN_HISTORY (4)
 #endif
+#define OFFLOAD_STREAM_OUT_PREBUFFER (16484 * 4)
 
 pa_stream *pa_stream_new(pa_context *c, const char *name, const pa_sample_spec *ss, const pa_channel_map *map) {
     return pa_stream_new_with_proplist(c, name, ss, map, NULL);
@@ -1703,7 +1704,8 @@ size_t pa_stream_readable_size(const pa_stream *s) {
 pa_operation * pa_stream_drain(pa_stream *s, pa_stream_success_cb_t cb, void *userdata) {
     pa_operation *o;
     pa_tagstruct *t;
-    uint32_t tag;
+    uint32_t tag, drain_buffer_size = 0, drain_time = 0;
+    uint32_t *offload_stream_bitrate = userdata;
 
     pa_assert(s);
     pa_assert(PA_REFCNT_VALUE(s) >= 1);
@@ -1722,7 +1724,15 @@ pa_operation * pa_stream_drain(pa_stream *s, pa_stream_success_cb_t cb, void *us
     t = pa_tagstruct_command(s->context, PA_COMMAND_DRAIN_PLAYBACK_STREAM, &tag);
     pa_tagstruct_putu32(t, s->channel);
     pa_pstream_send_tagstruct(s->context->pstream, t);
-    pa_pdispatch_register_reply(s->context->pdispatch, tag, DEFAULT_TIMEOUT, pa_stream_simple_ack_callback, pa_operation_ref(o), (pa_free_cb_t) pa_operation_unref);
+    if (pa_format_info_is_compressed(s->format)) {
+        drain_buffer_size = s->buffer_attr.tlength + OFFLOAD_STREAM_OUT_PREBUFFER;
+        if (offload_stream_bitrate)
+            drain_time = (drain_buffer_size * 8) / *offload_stream_bitrate;
+        pa_pdispatch_register_reply(s->context->pdispatch, tag, DEFAULT_TIMEOUT + drain_time, pa_stream_simple_ack_callback, pa_operation_ref(o), (pa_free_cb_t) pa_operation_unref);
+    }
+    else
+        pa_pdispatch_register_reply(s->context->pdispatch, tag, DEFAULT_TIMEOUT, pa_stream_simple_ack_callback, pa_operation_ref(o), (pa_free_cb_t) pa_operation_unref);
+
 
     /* This might cause the read index to continue again, hence
      * let's request a timing update */
@@ -1742,6 +1752,13 @@ static pa_usec_t calc_time(const pa_stream *s, bool ignore_transport) {
     pa_assert(s->direction != PA_STREAM_PLAYBACK || !s->timing_info.read_index_corrupt);
     pa_assert(s->direction != PA_STREAM_RECORD || !s->timing_info.write_index_corrupt);
 
+    /* Get a time value (rather than bytes) for compressed streams */
+    if (s->format && pa_format_info_is_compressed(s->format)) {
+        if ((usec = s->timing_info.sink_sess_usec) > 0) {
+            goto finish;
+        }
+    }
+
     if (s->direction == PA_STREAM_PLAYBACK) {
         /* The last byte that was written into the output device
          * had this time value associated */
@@ -1789,6 +1806,7 @@ static pa_usec_t calc_time(const pa_stream *s, bool ignore_transport) {
         }
     }
 
+finish:
     return usec;
 }
 
@@ -1819,6 +1837,7 @@ static void stream_get_timing_info_callback(pa_pdispatch *pd, uint32_t command,
     } else {
 
         if (pa_tagstruct_get_usec(t, &i->sink_usec) < 0 ||
+            pa_tagstruct_get_usec(t, &i->sink_sess_usec) < 0 ||
             pa_tagstruct_get_usec(t, &i->source_usec) < 0 ||
             pa_tagstruct_get_boolean(t, &playing) < 0 ||
             pa_tagstruct_get_timeval(t, &local) < 0 ||
diff --git a/src/pulsecore/core-format.c b/src/pulsecore/core-format.c
index 1a218644b..5accde03c 100644
--- a/src/pulsecore/core-format.c
+++ b/src/pulsecore/core-format.c
@@ -136,7 +136,22 @@ int pa_format_info_to_sample_spec_fake(const pa_format_info *f, pa_sample_spec *
     /* Note: When we add support for non-IEC61937 encapsulated compressed
      * formats, this function should return a non-zero values for these. */
 
-    ss->format = PA_SAMPLE_S16LE;
+    switch (f->encoding) {
+        case PA_ENCODING_PCM:
+            return -PA_ERR_INVALID;
+
+        case PA_ENCODING_MPEG:
+        case PA_ENCODING_AAC:
+            /* Fake a frame size of 1 byte for compressed data */
+            ss->format = PA_SAMPLE_U8;
+            break;
+
+        default:
+            /* Passthrough format */
+            ss->format = PA_SAMPLE_S16LE;
+            break;
+    }
+
     if ((f->encoding == PA_ENCODING_TRUEHD_IEC61937) ||
         (f->encoding == PA_ENCODING_DTSHD_IEC61937)) {
         ss->channels = 8;
@@ -148,6 +163,12 @@ int pa_format_info_to_sample_spec_fake(const pa_format_info *f, pa_sample_spec *
              * sample spec's channel count. */
             pa_channel_map_init_auto(map, 8, PA_CHANNEL_MAP_ALSA);
         }
+    } else if (f->encoding == PA_ENCODING_MPEG ||
+               f->encoding == PA_ENCODING_AAC) {
+        /* Fake a frame size of 1 byte for compressed data */
+        ss->channels = 1;
+        if (map)
+            pa_channel_map_init_mono(map);
     } else {
         ss->channels = 2;
         if (map)
diff --git a/src/pulsecore/memchunk.h b/src/pulsecore/memchunk.h
index 2b197129a..92cc885a7 100644
--- a/src/pulsecore/memchunk.h
+++ b/src/pulsecore/memchunk.h
@@ -31,6 +31,7 @@ typedef struct pa_memchunk pa_memchunk;
 struct pa_memchunk {
     pa_memblock *memblock;
     size_t index, length;
+    uint64_t timestamp, duration;
 };
 
 /* Make a memchunk writable, i.e. make sure that the caller may have
diff --git a/src/pulsecore/meson.build b/src/pulsecore/meson.build
index d7f9ef2cf..984725db1 100644
--- a/src/pulsecore/meson.build
+++ b/src/pulsecore/meson.build
@@ -172,45 +172,18 @@ endif
 
 # FIXME: SIMD support (ORC)
 simd = import('unstable-simd')
-simd_variants = [
-  { 'mmx' : ['remap_mmx.c', 'svolume_mmx.c'] },
-  { 'sse' : ['remap_sse.c', 'sconv_sse.c', 'svolume_sse.c'] },
-  { 'neon' : ['remap_neon.c', 'sconv_neon.c', 'mix_neon.c'] },
-]
-
-libpulsecore_simd_lib = []
-
-foreach simd_kwargs : simd_variants
-
-  if host_machine.cpu_family() == 'arm' and 'neon' in simd_kwargs
-    if not cc.compiles('''
-        #include <arm_neon.h>
-        int main() {
-            return sizeof(uint8x8_t) + sizeof(int32x4_t) + sizeof(float32x4_t);
-        }
-        ''', name : 'neon code')
-      continue
-    endif
-  endif
-
-  libpulsecore_simd = simd.check('libpulsecore_simd',
-    kwargs : simd_kwargs,
-    c_args : [pa_c_args],
-    include_directories : [configinc, topinc],
-    implicit_include_directories : false,
-    compiler : cc)
+libpulsecore_simd = simd.check('libpulsecore_simd',
+  mmx : ['remap_mmx.c', 'svolume_mmx.c'],
+  sse : ['remap_sse.c', 'sconv_sse.c', 'svolume_sse.c'],
+  neon : ['remap_neon.c', 'sconv_neon.c', 'mix_neon.c'],
+  c_args : [pa_c_args],
+  include_directories : [configinc, topinc],
+  implicit_include_directories : false,
+  compiler : cc)
+libpulsecore_simd_lib = libpulsecore_simd[0]
+cdata.merge_from(libpulsecore_simd[1])
 
-  libpulsecore_simd_lib += libpulsecore_simd[0]
-  cdata.merge_from(libpulsecore_simd[1])
-endforeach
 
-if host_machine.system() == 'windows'
-  libpulsecore_sources += ['mutex-win32.c',
-    'poll-win32.c',
-    'semaphore-win32.c',
-    'thread-win32.c',
-  ]
-endif
 
 libpulsecore = shared_library('pulsecore-' + pa_version_major_minor,
   libpulsecore_sources, libpulsecore_headers,
diff --git a/src/pulsecore/protocol-native.c b/src/pulsecore/protocol-native.c
index f8dad57d6..e3f2106f0 100644
--- a/src/pulsecore/protocol-native.c
+++ b/src/pulsecore/protocol-native.c
@@ -145,6 +145,7 @@ typedef struct playback_stream {
     int64_t read_index, write_index;
     size_t render_memblockq_length;
     pa_usec_t current_sink_latency;
+    uint64_t current_sink_sess_time;
     uint64_t playing_for, underrun_for;
 } playback_stream;
 
@@ -248,6 +249,7 @@ static void sink_input_process_rewind_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_update_max_rewind_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_update_max_request_cb(pa_sink_input *i, size_t nbytes);
 static void sink_input_send_event_cb(pa_sink_input *i, const char *event, pa_proplist *pl);
+static void sink_input_drain_complete_cb(pa_sink_input *i);
 
 static void native_connection_send_memblock(pa_native_connection *c);
 static void playback_stream_request_bytes(struct playback_stream*s);
@@ -1064,6 +1066,7 @@ static playback_stream* playback_stream_new(
     s->sink_input->moving = sink_input_moving_cb;
     s->sink_input->suspend = sink_input_suspend_cb;
     s->sink_input->send_event = sink_input_send_event_cb;
+    s->sink_input->drain_complete = sink_input_drain_complete_cb;
     s->sink_input->userdata = s;
 
     start_index = ssync ? pa_memblockq_get_read_index(ssync->memblockq) : 0;
@@ -1404,7 +1407,35 @@ static int sink_input_process_msg(pa_msgobject *o, int code, void *userdata, int
                 handle_seek(ssync, windex);
             }
 
-            if (code == SINK_INPUT_MESSAGE_DRAIN) {
+            /* For compressed streams, we need to send the flush all the way to
+             * the sink so that it can drop any buffered data if possible. */
+            if (pa_sink_input_is_compressed(i)) {
+                switch (code) {
+                    case SINK_INPUT_MESSAGE_FLUSH:
+                        if (pa_sink_flush(i->sink) < 0)
+                            pa_log_warn("Unable to flush sink");
+                        break;
+
+                    case SINK_INPUT_MESSAGE_DRAIN:
+                        s->drain_tag = PA_PTR_TO_UINT(userdata);
+
+                        if (!pa_memblockq_is_readable(s->memblockq)) {
+                            if (pa_sink_drain(i->sink) < 0) {
+                                pa_log_warn("Unable to drain sink");
+                                /* We're not going to get an ack from the sink,
+                                 * tell the clientto not wait */
+                                pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, userdata, 0, NULL, NULL);
+                            }
+                        } else {
+                            /* Schedule the drain for when the buffer runs empty */
+                            s->drain_request = true;
+                        }
+
+                    default:
+                        break;
+                }
+            } else if (code == SINK_INPUT_MESSAGE_DRAIN) {
+                /* Handle drains for non-compressed streams */
                 if (!pa_memblockq_is_readable(s->memblockq))
                     pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, userdata, 0, NULL, NULL);
                 else {
@@ -1422,6 +1453,7 @@ static int sink_input_process_msg(pa_msgobject *o, int code, void *userdata, int
             s->write_index = pa_memblockq_get_write_index(s->memblockq);
             s->render_memblockq_length = pa_memblockq_get_length(s->sink_input->thread_info.render_memblockq);
             s->current_sink_latency = pa_sink_get_latency_within_thread(s->sink_input->sink, false);
+            s->current_sink_sess_time = s->sink_input->sink->sess_time;
             /* Add resampler latency */
             s->current_sink_latency += pa_resampler_get_delay_usec(i->thread_info.resampler);
             s->underrun_for = s->sink_input->thread_info.underrun_for;
@@ -1476,12 +1508,26 @@ static bool handle_input_underrun(playback_stream *s, bool force) {
         pa_log_debug("%s %s of '%s'", force ? "Actual" : "Implicit",
             s->drain_request ? "drain" : "underrun", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
 
-    send_drain = s->drain_request && (force || pa_sink_input_safe_to_remove(s->sink_input));
+    send_drain = s->drain_request && (force || pa_sink_input_safe_to_remove(s->sink_input) || pa_sink_input_is_compressed(s->sink_input));
 
     if (send_drain) {
-         s->drain_request = false;
-         pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
-         pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+         if (!pa_sink_input_is_compressed(s->sink_input)) {
+             s->drain_request = false;
+             pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+             pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+         } else {
+             /* Now trigger a drain on the (compressed) sink as well */
+             if (pa_sink_drain(s->sink_input->sink) < 0) {
+                 s->drain_request = false;
+                 pa_log_warn("Unable to drain sink");
+                 /* We're not going to get an ack from the sink, tell the
+                  * client to not wait */
+                 pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+             } else {
+                 /* s->drain_request is still true, and will get cleared on
+                  * completion of the drain */
+             }
+         }
     } else if (!s->is_underrun) {
          pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_UNDERFLOW, NULL, pa_memblockq_get_read_index(s->memblockq), NULL, NULL);
     }
@@ -1618,6 +1664,24 @@ static void sink_input_send_event_cb(pa_sink_input *i, const char *event, pa_pro
     pa_pstream_send_tagstruct(s->connection->pstream, t);
 }
 
+/* Called from thread context */
+static void sink_input_drain_complete_cb(pa_sink_input *i)
+{
+    playback_stream *s;
+
+    pa_sink_input_assert_ref(i);
+    s = PLAYBACK_STREAM(i->userdata);
+    playback_stream_assert_ref(s);
+
+    /* This can happen if a sink was in the middle of a drain, a sink-input
+     * went away, and a new one came in */
+    if (!s->drain_request)
+        return;
+
+    pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(s), PLAYBACK_STREAM_MESSAGE_DRAIN_ACK, PA_UINT_TO_PTR(s->drain_tag), 0, NULL, NULL);
+    pa_log_debug("Drain acknowledged of '%s'", pa_strnull(pa_proplist_gets(s->sink_input->proplist, PA_PROP_MEDIA_NAME)));
+}
+
 /* Called from main context */
 static void sink_input_suspend_cb(pa_sink_input *i, pa_sink_state_t old_state, pa_suspend_cause_t old_suspend_cause) {
     playback_stream *s;
@@ -2898,6 +2962,7 @@ static void command_get_playback_latency(pa_pdispatch *pd, uint32_t command, uin
     pa_tagstruct_put_usec(reply,
                           s->current_sink_latency +
                           pa_bytes_to_usec(s->render_memblockq_length, &s->sink_input->sink->sample_spec));
+    pa_tagstruct_put_usec(reply, s->current_sink_sess_time);
     pa_tagstruct_put_usec(reply, 0);
     pa_tagstruct_put_boolean(reply,
                              s->playing_for > 0 &&
@@ -2942,6 +3007,7 @@ static void command_get_record_latency(pa_pdispatch *pd, uint32_t command, uint3
 
     reply = reply_new(tag);
     pa_tagstruct_put_usec(reply, s->current_monitor_latency);
+    pa_tagstruct_put_usec(reply, 0);
     pa_tagstruct_put_usec(reply,
                           s->current_source_latency +
                           pa_bytes_to_usec(s->on_the_fly_snapshot, &s->source_output->sample_spec));
diff --git a/src/pulsecore/rtpoll.c b/src/pulsecore/rtpoll.c
index 1085bf957..85749ca97 100644
--- a/src/pulsecore/rtpoll.c
+++ b/src/pulsecore/rtpoll.c
@@ -549,10 +549,11 @@ static int asyncmsgq_read_work(pa_rtpoll_item *i) {
     void *data;
     pa_memchunk chunk;
     int64_t offset;
+    int processed = 0;
 
     pa_assert(i);
 
-    if (pa_asyncmsgq_get(i->work_userdata, &object, &code, &data, &offset, &chunk, 0) == 0) {
+    while (pa_asyncmsgq_get(i->work_userdata, &object, &code, &data, &offset, &chunk, 0) == 0) {
         int ret;
 
         if (!object && code == PA_MESSAGE_SHUTDOWN) {
@@ -565,10 +566,10 @@ static int asyncmsgq_read_work(pa_rtpoll_item *i) {
 
         ret = pa_asyncmsgq_dispatch(object, code, data, offset, &chunk);
         pa_asyncmsgq_done(i->work_userdata, ret);
-        return 1;
+        processed++;
     }
 
-    return 0;
+    return processed;
 }
 
 pa_rtpoll_item *pa_rtpoll_item_new_asyncmsgq_read(pa_rtpoll *p, pa_rtpoll_priority_t prio, pa_asyncmsgq *q) {
diff --git a/src/pulsecore/sink-input.c b/src/pulsecore/sink-input.c
index 5e7657c45..b78bb122f 100644
--- a/src/pulsecore/sink-input.c
+++ b/src/pulsecore/sink-input.c
@@ -87,7 +87,7 @@ static void sink_input_free(pa_object *o);
 static void set_real_ratio(pa_sink_input *i, const pa_cvolume *v);
 
 static int check_passthrough_connection(bool passthrough, pa_sink *dest) {
-    if (pa_sink_is_passthrough(dest)) {
+    if (pa_sink_is_exclusive(dest)) {
         pa_log_warn("Sink is already connected to PASSTHROUGH input");
         return -PA_ERR_BUSY;
     }
@@ -131,10 +131,22 @@ void pa_sink_input_new_data_set_channel_map(pa_sink_input_new_data *data, const
         data->channel_map = *map;
 }
 
+bool pa_sink_input_new_data_is_pcm(pa_sink_input_new_data *data) {
+    pa_assert(data);
+
+    if (data->format && pa_format_info_is_pcm(data->format))
+        return true;
+
+    if (!data->format)
+        return true;
+
+    return false;
+}
+
 bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data) {
     pa_assert(data);
 
-    if (PA_LIKELY(data->format) && PA_UNLIKELY(!pa_format_info_is_pcm(data->format)))
+    if (PA_LIKELY(data->format) && PA_UNLIKELY(pa_format_info_is_passthrough(data->format)))
         return true;
 
     if (PA_UNLIKELY(data->flags & PA_SINK_INPUT_PASSTHROUGH))
@@ -143,6 +155,15 @@ bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data) {
     return false;
 }
 
+bool pa_sink_input_new_data_is_compressed(pa_sink_input_new_data *data) {
+    pa_assert(data);
+
+    if (data->format && pa_format_info_is_compressed(data->format))
+        return true;
+
+    return false;
+}
+
 void pa_sink_input_new_data_set_volume(pa_sink_input_new_data *data, const pa_cvolume *volume) {
     pa_assert(data);
     pa_assert(data->volume_writable);
@@ -373,7 +394,7 @@ int pa_sink_input_new(
 
     /* Routing is done. We have a sink and a format. */
 
-    if (data->volume_is_set && !pa_sink_input_new_data_is_passthrough(data)) {
+    if (data->volume_is_set && pa_sink_input_new_data_is_pcm(data)) {
         /* If volume is set, we need to save the original data->channel_map,
          * so that we can remap the volume from the original channel map to the
          * final channel map of the stream in case data->channel_map gets
@@ -400,7 +421,7 @@ int pa_sink_input_new(
 
     /* Don't restore (or save) stream volume for passthrough streams and
      * prevent attenuation/gain */
-    if (pa_sink_input_new_data_is_passthrough(data)) {
+    if (!pa_sink_input_new_data_is_pcm(data)) {
         data->volume_is_set = true;
         pa_cvolume_reset(&data->volume, data->sample_spec.channels);
         data->volume_is_absolute = true;
@@ -424,13 +445,22 @@ int pa_sink_input_new(
     if (!data->muted_is_set)
         data->muted = false;
 
-    if (!(data->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
-        !pa_sample_spec_equal(&data->sample_spec, &data->sink->sample_spec)) {
-        /* try to change sink format and rate. This is done before the FIXATE hook since
-           module-suspend-on-idle can resume a sink */
+    if (!pa_sink_input_new_data_is_compressed(data)) {
+        if ((!(data->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+            !pa_sample_spec_equal(&data->sample_spec, &data->sink->sample_spec)) ||
+            pa_sink_input_new_data_is_passthrough(data)) {
+            /* try to change sink format and rate. This is done before the FIXATE hook since
+            module-suspend-on-idle can resume a sink */
 
-        pa_log_info("Trying to change sample spec");
-        pa_sink_reconfigure(data->sink, &data->sample_spec, pa_sink_input_new_data_is_passthrough(data));
+            pa_log_info("Trying to change sample spec");
+            pa_sink_reconfigure(data->sink, &data->sample_spec, pa_sink_input_new_data_is_passthrough(data));
+        }
+    } else {
+        /* Set the compressed format on the sink */
+        if (!pa_sink_set_format(data->sink, data->format)) {
+            pa_log_info("Could not configure sink for: %s", pa_format_info_snprint(fmt, sizeof(fmt), data->format));
+            return -PA_ERR_NOTSUPPORTED;
+        }
     }
 
     if (pa_sink_input_new_data_is_passthrough(data) &&
@@ -465,7 +495,7 @@ int pa_sink_input_new(
         !pa_channel_map_equal(&data->channel_map, &data->sink->channel_map)) {
 
         /* Note: for passthrough content we need to adjust the output rate to that of the current sink-input */
-        if (!pa_sink_input_new_data_is_passthrough(data)) /* no resampler for passthrough content */
+        if (pa_sink_input_new_data_is_pcm(data)) /* no resampler for passthrough/compressed content */
             if (!(resampler = pa_resampler_new(
                           core->mempool,
                           &data->sample_spec, &data->channel_map,
@@ -623,6 +653,7 @@ static void sink_input_set_state(pa_sink_input *i, pa_sink_input_state_t state)
 
     if (i->sink) {
         if (i->state == PA_SINK_INPUT_CORKED && state == PA_SINK_INPUT_RUNNING && pa_sink_used_by(i->sink) == 0 &&
+            !pa_sink_input_is_compressed(i) &&
             !pa_sample_spec_equal(&i->sample_spec, &i->sink->sample_spec)) {
             /* We were uncorked and the sink was not playing anything -- let's try
              * to update the sample format and rate to avoid resampling */
@@ -729,9 +760,15 @@ void pa_sink_input_unlink(pa_sink_input *i) {
     reset_callbacks(i);
 
     if (i->sink) {
-        if (PA_SINK_IS_LINKED(i->sink->state))
+        if (PA_SINK_IS_LINKED(i->sink->state)) {
             pa_sink_update_status(i->sink);
 
+            if (pa_sink_input_is_compressed(i)) {
+                if (!pa_sink_set_format(i->sink, NULL))
+                    pa_log_warn("Sink could not exit compressed mode");
+            }
+        }
+
         i->sink = NULL;
     }
 
@@ -1391,11 +1428,24 @@ static void set_real_ratio(pa_sink_input *i, const pa_cvolume *v) {
     /* We don't copy the data to the thread_info data. That's left for someone else to do */
 }
 
+/* Called from main or I/O context */
+bool pa_sink_input_is_pcm(pa_sink_input *i) {
+    pa_sink_input_assert_ref(i);
+
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(i->format) || pa_format_info_is_compressed(i->format)))
+        return false;
+
+    if (PA_UNLIKELY(i->flags & PA_SINK_INPUT_PASSTHROUGH))
+        return false;
+
+    return true;
+}
+
 /* Called from main or I/O context */
 bool pa_sink_input_is_passthrough(pa_sink_input *i) {
     pa_sink_input_assert_ref(i);
 
-    if (PA_UNLIKELY(!pa_format_info_is_pcm(i->format)))
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(i->format)))
         return true;
 
     if (PA_UNLIKELY(i->flags & PA_SINK_INPUT_PASSTHROUGH))
@@ -1404,6 +1454,16 @@ bool pa_sink_input_is_passthrough(pa_sink_input *i) {
     return false;
 }
 
+/* Called from main or I/O context */
+bool pa_sink_input_is_compressed(pa_sink_input *i) {
+    pa_sink_input_assert_ref(i);
+
+    if (PA_UNLIKELY(pa_format_info_is_compressed(i->format)))
+        return true;
+
+    return false;
+}
+
 /* Called from main context */
 bool pa_sink_input_is_volume_readable(pa_sink_input *i) {
     pa_sink_input_assert_ref(i);
@@ -1929,8 +1989,10 @@ int pa_sink_input_finish_move(pa_sink_input *i, pa_sink *dest, bool save) {
         return -PA_ERR_NOTSUPPORTED;
     }
 
-    if (!(i->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
-        !pa_sample_spec_equal(&i->sample_spec, &dest->sample_spec)) {
+    if ((!(i->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+         !pa_sink_input_is_compressed(i) &&
+         !pa_sample_spec_equal(&i->sample_spec, &dest->sample_spec)) ||
+         pa_sink_input_is_passthrough(i)) {
         /* try to change dest sink format and rate if possible without glitches.
            module-suspend-on-idle resumes destination sink with
            SINK_INPUT_MOVE_FINISH hook */
@@ -2475,3 +2537,9 @@ void pa_sink_input_set_preferred_sink(pa_sink_input *i, pa_sink *s) {
         pa_sink_input_move_to(i, i->core->default_sink, false);
     }
 }
+
+/* Called from IO context */
+void pa_sink_input_drain_complete(pa_sink_input *i) {
+    if (i->drain_complete)
+        i->drain_complete(i);
+}
diff --git a/src/pulsecore/sink-input.h b/src/pulsecore/sink-input.h
index d3de6e3f8..bd53fda1f 100644
--- a/src/pulsecore/sink-input.h
+++ b/src/pulsecore/sink-input.h
@@ -231,6 +231,11 @@ struct pa_sink_input {
      * mute status changes. Called from main context */
     void (*mute_changed)(pa_sink_input *i); /* may be NULL */
 
+    /* If non-NULL this function is called when for a compressed
+     * stream, a drain was called and the sink has completed the
+     * drain request */
+    void (*drain_complete)(pa_sink_input *i); /* may be NULL */
+
     /* Used to store the rewind amount of the origin sink during a move */
     size_t origin_rewind_bytes;    /* In sink input sample spec */

@@ -328,7 +333,9 @@ typedef struct pa_sink_input_new_data {
 pa_sink_input_new_data* pa_sink_input_new_data_init(pa_sink_input_new_data *data);
 void pa_sink_input_new_data_set_sample_spec(pa_sink_input_new_data *data, const pa_sample_spec *spec);
 void pa_sink_input_new_data_set_channel_map(pa_sink_input_new_data *data, const pa_channel_map *map);
+bool pa_sink_input_new_data_is_pcm(pa_sink_input_new_data *data);
 bool pa_sink_input_new_data_is_passthrough(pa_sink_input_new_data *data);
+bool pa_sink_input_new_data_is_compressed(pa_sink_input_new_data *data);
 void pa_sink_input_new_data_set_volume(pa_sink_input_new_data *data, const pa_cvolume *volume);
 void pa_sink_input_new_data_add_volume_factor(pa_sink_input_new_data *data, const char *key, const pa_cvolume *volume_factor);
 void pa_sink_input_new_data_add_volume_factor_sink(pa_sink_input_new_data *data, const char *key, const pa_cvolume *volume_factor);
@@ -374,7 +381,9 @@ void pa_sink_input_kill(pa_sink_input*i);
 
 pa_usec_t pa_sink_input_get_latency(pa_sink_input *i, pa_usec_t *sink_latency);
 
+bool pa_sink_input_is_pcm(pa_sink_input *i);
 bool pa_sink_input_is_passthrough(pa_sink_input *i);
+bool pa_sink_input_is_compressed(pa_sink_input *i);
 bool pa_sink_input_is_volume_readable(pa_sink_input *i);
 void pa_sink_input_set_volume(pa_sink_input *i, const pa_cvolume *volume, bool save, bool absolute);
 void pa_sink_input_add_volume_factor(pa_sink_input *i, const char *key, const pa_cvolume *volume_factor);
@@ -421,6 +430,9 @@ pa_usec_t pa_sink_input_set_requested_latency_within_thread(pa_sink_input *i, pa
 bool pa_sink_input_safe_to_remove(pa_sink_input *i);
 bool pa_sink_input_process_underrun(pa_sink_input *i);
 
+/* Used by compressed sinks to signal end of drain */
+void pa_sink_input_drain_complete(pa_sink_input *i);
+
 pa_memchunk* pa_sink_input_get_silence(pa_sink_input *i, pa_memchunk *ret);
 
 /* Calls the attach() callback if it's set. The input must be in detached
diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index 905e1db7b..9971665ed 100644
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -38,6 +38,7 @@
 #include <pulsecore/i18n.h>
 #include <pulsecore/sink-input.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/core-format.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/sample-util.h>
 #include <pulsecore/stream-util.h>
@@ -354,6 +355,8 @@ pa_sink* pa_sink_new(
     s->thread_info.volume_change_extra_delay = core->deferred_volume_extra_delay_usec;
     s->thread_info.port_latency_offset = s->port_latency_offset;
 
+    s->sess_time = 0;
+
     /* FIXME: This should probably be moved to pa_sink_put() */
     pa_assert_se(pa_idxset_put(core->sinks, s, &s->index) >= 0);
 
@@ -1538,7 +1541,7 @@ void pa_sink_reconfigure(pa_sink *s, pa_sample_spec *spec, bool passthrough) {
             desired_spec.rate = default_rate;
     }
 
-    if (pa_sample_spec_equal(&desired_spec, &s->sample_spec) && passthrough == pa_sink_is_passthrough(s))
+    if (pa_sample_spec_equal(&desired_spec, &s->sample_spec) && passthrough == pa_sink_is_exclusive(s))
         return;
 
     if (!passthrough && pa_sink_used_by(s) > 0)
@@ -1662,17 +1665,17 @@ bool pa_sink_is_filter(pa_sink *s) {
 }
 
 /* Called from main context */
-bool pa_sink_is_passthrough(pa_sink *s) {
+bool pa_sink_is_exclusive(pa_sink *s) {
     pa_sink_input *alt_i;
     uint32_t idx;
 
     pa_sink_assert_ref(s);
 
-    /* one and only one PASSTHROUGH input can possibly be connected */
+    /* one and only one passthrough or compressed input can possibly be connected */
     if (pa_idxset_size(s->inputs) == 1) {
         alt_i = pa_idxset_first(s->inputs, &idx);
 
-        if (pa_sink_input_is_passthrough(alt_i))
+        if (!pa_sink_input_is_pcm(alt_i))
             return true;
     }
 
@@ -2099,13 +2102,6 @@ void pa_sink_set_volume(
     pa_assert(volume || pa_sink_flat_volume_enabled(s));
     pa_assert(!volume || volume->channels == 1 || pa_cvolume_compatible(volume, &s->sample_spec));
 
-    /* make sure we don't change the volume when a PASSTHROUGH input is connected ...
-     * ... *except* if we're being invoked to reset the volume to ensure 0 dB gain */
-    if (pa_sink_is_passthrough(s) && (!volume || !pa_cvolume_is_norm(volume))) {
-        pa_log_warn("Cannot change volume, Sink is connected to PASSTHROUGH input");
-        return;
-    }
-
     /* In case of volume sharing, the volume is set for the root sink first,
      * from which it's then propagated to the sharing sinks. */
     root_sink = pa_sink_get_master(s);
@@ -3837,6 +3833,44 @@ pa_idxset* pa_sink_get_formats(pa_sink *s) {
     return ret;
 }
 
+/* Called from the main thread */
+/* Configures the sink for this specific (compressed) format */
+bool pa_sink_set_format(pa_sink *s, pa_format_info *f) {
+    pa_channel_map old_map;
+    bool ret;
+
+    pa_assert(s);
+
+    if (!s->set_format)
+        return false;
+
+    old_map = s->channel_map;
+
+    if (f) {
+        s->saved_spec = s->sample_spec;
+        s->saved_map = s->channel_map;
+
+        pa_format_info_to_sample_spec_fake(f, &s->sample_spec, &s->channel_map);
+    } else {
+        s->sample_spec = s->saved_spec;
+        s->channel_map = s->saved_map;
+
+        /* Invalidate to make sure we don't reuse this unexpectedly */
+        pa_sample_spec_init(&s->saved_spec);
+        pa_channel_map_init(&s->saved_map);
+    }
+
+    /* Fixup volumes to be valid */
+    pa_cvolume_remap(&s->reference_volume, &old_map, &s->channel_map);
+    pa_cvolume_remap(&s->real_volume, &old_map, &s->channel_map);
+    pa_cvolume_remap(&s->soft_volume, &old_map, &s->channel_map);
+
+    /* Set the format on the sink */
+    ret = s->set_format(s, f);
+
+    return ret;
+}
+
 /* Called from the main thread */
 /* Allows an external source to set what formats a sink supports if the sink
  * permits this. The function makes a copy of the formats on success. */
@@ -4015,3 +4049,45 @@ void pa_sink_move_streams_to_default_sink(pa_core *core, pa_sink *old_sink, bool
         pa_sink_input_move_to(i, core->default_sink, false);
     }
 }
+
+/* Called from the IO thread. */
+int pa_sink_flush(pa_sink *s) {
+	pa_assert(s);
+	pa_assert_io_context();
+
+	if (s->flush)
+		return s->flush(s);
+	else
+		return -1;
+}
+
+/* Called from the IO thread. */
+int pa_sink_drain(pa_sink *s) {
+    pa_assert(s);
+    pa_assert_io_context();
+
+    if (s->drain)
+        return s->drain(s);
+    else
+        return -1;
+}
+
+/* Called from the IO thread. */
+void pa_sink_drain_complete(pa_sink *s) {
+    pa_sink_input *i;
+    uint32_t idx;
+
+    pa_assert(s);
+    pa_assert_io_context();
+
+    /* There should be only one stream in compressed mode */
+    i = pa_idxset_first(s->inputs, &idx);
+
+    /* See if the sink input is still there */
+    if (!i)
+        return;
+
+    pa_assert(pa_sink_input_is_compressed(i));
+
+    pa_sink_input_drain_complete(i);
+}
diff --git a/src/pulsecore/sink.h b/src/pulsecore/sink.h
index 87bfddd0b..e87b86a3e 100644
--- a/src/pulsecore/sink.h
+++ b/src/pulsecore/sink.h
@@ -107,7 +107,9 @@ struct pa_sink {
     bool save_muted:1;
     bool port_changing:1;
 
-    /* Saved volume state while we're in passthrough mode */
+    /* Saved state while we're in passthrough or compressed mode */
+    pa_sample_spec saved_spec;
+    pa_channel_map saved_map;
     pa_cvolume saved_volume;
     bool saved_save_volume:1;
 
@@ -266,10 +268,25 @@ struct pa_sink {
      * set). Makes a copy of the formats passed in. */
     bool (*set_formats)(pa_sink *s, pa_idxset *formats); /* may be NULL */
 
+    /* Called to inform the sink that a specific compressed stream will
+     * now be providing data to it, or to end such a configured state
+     * if the format is NULL. Must return success or failure value for
+     * whether such a configuration was successful.
+     */
+    bool (*set_format)(pa_sink *s, const pa_format_info *format); /* may be NULL */
+
     /* Called whenever device parameters need to be changed. Called from
      * main thread. */
     void (*reconfigure)(pa_sink *s, pa_sample_spec *spec, bool passthrough);
 
+    /* Called in compressed mode to flush any buffered data in the sink */
+    int (*flush)(pa_sink *s);
+
+    /* Called in compressed mode to drain any buffered data in the sink.
+     * The expectation is that this will be completed asynchronously,
+     * and when complete, pa_sink_drain_complete() must be called. */
+    int (*drain)(pa_sink *s);
+
     /* Contains copies of the above data so that the real-time worker
      * thread can work without access locking */
     struct {
@@ -328,6 +345,8 @@ struct pa_sink {
         int32_t volume_change_extra_delay;
     } thread_info;
 
+    pa_usec_t sess_time;
+
     void *userdata;
 };
 
@@ -470,9 +489,10 @@ pa_sink *pa_sink_get_master(pa_sink *s);
 
 bool pa_sink_is_filter(pa_sink *s);
 
-/* Is the sink in passthrough mode? (that is, is there a passthrough sink input
- * connected to this sink? */
-bool pa_sink_is_passthrough(pa_sink *s);
+/* Is the sink in exclusive mode? (that is, is there a passthrough or
+ * compressed sink input connected to this sink?) */
+bool pa_sink_is_exclusive(pa_sink *s);
+
 /* These should be called when a sink enters/leaves passthrough mode */
 void pa_sink_enter_passthrough(pa_sink *s);
 void pa_sink_leave_passthrough(pa_sink *s);
@@ -511,6 +531,7 @@ void pa_sink_move_all_fail(pa_queue *q);
  * https://bugs.freedesktop.org/show_bug.cgi?id=71924 */
 pa_idxset* pa_sink_get_formats(pa_sink *s);
 
+bool pa_sink_set_format(pa_sink *s, pa_format_info *format);
 bool pa_sink_set_formats(pa_sink *s, pa_idxset *formats);
 bool pa_sink_check_format(pa_sink *s, pa_format_info *f);
 pa_idxset* pa_sink_check_formats(pa_sink *s, pa_idxset *in_formats);
@@ -567,6 +588,12 @@ void pa_sink_set_reference_volume_direct(pa_sink *s, const pa_cvolume *volume);
  * current default_sink conditionally*/
 void pa_sink_move_streams_to_default_sink(pa_core *core, pa_sink *old_sink, bool default_sink_changed);
 
+int pa_sink_flush(pa_sink *s);
+
+int pa_sink_drain(pa_sink *s);
+
+void pa_sink_drain_complete(pa_sink *s);
+
 /* Verify that we called in IO context (aka 'thread context), or that
  * the sink is not yet set up, i.e. the thread not set up yet. See
  * pa_assert_io_context() in thread-mq.h for more information. */
diff --git a/src/pulsecore/source-output.c b/src/pulsecore/source-output.c
index bee9241b9..d7256f4d1 100644
--- a/src/pulsecore/source-output.c
+++ b/src/pulsecore/source-output.c
@@ -75,7 +75,7 @@ void pa_source_output_new_data_set_channel_map(pa_source_output_new_data *data,
 bool pa_source_output_new_data_is_passthrough(pa_source_output_new_data *data) {
     pa_assert(data);
 
-    if (PA_LIKELY(data->format) && PA_UNLIKELY(!pa_format_info_is_pcm(data->format)))
+    if (PA_LIKELY(data->format) && PA_UNLIKELY(pa_format_info_is_passthrough(data->format)))
         return true;
 
     if (PA_UNLIKELY(data->flags & PA_SOURCE_OUTPUT_PASSTHROUGH))
@@ -1047,7 +1047,7 @@ static void set_real_ratio(pa_source_output *o, const pa_cvolume *v) {
 bool pa_source_output_is_passthrough(pa_source_output *o) {
     pa_source_output_assert_ref(o);
 
-    if (PA_UNLIKELY(!pa_format_info_is_pcm(o->format)))
+    if (PA_UNLIKELY(pa_format_info_is_passthrough(o->format)))
         return true;
 
     if (PA_UNLIKELY(o->flags & PA_SOURCE_OUTPUT_PASSTHROUGH))
diff --git a/src/pulsecore/source.c b/src/pulsecore/source.c
index 99d8dde6e..ac483024b 100644
--- a/src/pulsecore/source.c
+++ b/src/pulsecore/source.c
@@ -1256,8 +1256,8 @@ bool pa_source_is_passthrough(pa_source *s) {
 
     pa_source_assert_ref(s);
 
-    /* NB Currently only monitor sources support passthrough mode */
-    return (s->monitor_of && pa_sink_is_passthrough(s->monitor_of));
+    /* Check if we're a monitor source and sink is in exclusive mode */
+    return (s->monitor_of && pa_sink_is_exclusive(s->monitor_of));
 }
 
 /* Called from main context */
diff --git a/src/pulsecore/tinymp3.h b/src/pulsecore/tinymp3.h
new file mode 100644
index 000000000..b0d429d5c
--- /dev/null
+++ b/src/pulsecore/tinymp3.h
@@ -0,0 +1,109 @@
+/*
+ * This file is provided under a dual BSD/LGPLv2.1 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * BSD LICENSE
+ *
+ * mp3 header and prasing
+ * Copyright (c) 2011-2012, Intel Corporation
+ * All rights reserved.
+ *
+ * Author: Vinod Koul <vinod.koul@linux.intel.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ * Neither the name of Intel Corporation nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * LGPL LICENSE
+ *
+ * mp3 header and parsing
+ * Copyright (c) 2011-2012, Intel Corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU Lesser General Public License,
+ * version 2.1, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to
+ * the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef __TINYMP3_H
+#define __TINYMP3_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+#define MP3_SYNC 0xe0ff
+
+static const int mp3_sample_rates[3][3] = {
+	{44100, 48000, 32000},        /* MPEG-1 */
+	{22050, 24000, 16000},        /* MPEG-2 */
+	{11025, 12000,  8000},        /* MPEG-2.5 */
+};
+
+static const int mp3_bit_rates[3][3][15] = {
+	{
+		/* MPEG-1 */
+		{  0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448}, /* Layer 1 */
+		{  0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384}, /* Layer 2 */
+		{  0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320}, /* Layer 3 */
+	},
+	{
+		/* MPEG-2 */
+		{  0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256}, /* Layer 1 */
+		{  0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}, /* Layer 2 */
+		{  0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}, /* Layer 3 */
+	},
+	{
+		/* MPEG-2.5 */
+		{  0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256}, /* Layer 1 */
+		{  0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}, /* Layer 2 */
+		{  0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}, /* Layer 3 */
+	},
+};
+
+enum mpeg_version {
+	MPEG1  = 0,
+	MPEG2  = 1,
+	MPEG25 = 2
+};
+
+enum mp3_stereo_mode {
+	STEREO = 0x00,
+	JOINT = 0x01,
+	DUAL = 0x02,
+	MONO = 0x03
+};
+
+#endif
diff --git a/src/utils/pacat.c b/src/utils/pacat.c
index 39ccaffd0..b13f010a9 100644
--- a/src/utils/pacat.c
+++ b/src/utils/pacat.c
@@ -43,12 +43,22 @@
 #include <pulsecore/log.h>
 #include <pulsecore/macro.h>
 #include <pulsecore/sndfile-util.h>
+#include <pulsecore/tinymp3.h>
 #include <pulsecore/sample-util.h>
 
 #define TIME_EVENT_USEC 50000
 
 #define CLEAR_LINE "\x1B[K"
 
+#define ID3V2_HEADER_SIZE 10
+#define ID3V2_FILE_IDENTIFIER_SIZE 3
+
+struct mp3_header {
+       uint16_t sync;
+       uint8_t format1;
+       uint8_t format2;
+};
+
 static enum { RECORD, PLAYBACK } mode = PLAYBACK;
 static const char *purpose = NULL;
 
@@ -100,6 +110,13 @@ static bool sample_spec_set = false;
 static pa_channel_map channel_map;
 static bool channel_map_set = false;
 
+/* If the encoding is set, we assume the pa_sample_spec will not be used, and
+ * that the pa_format_info will be. */
+static pa_encoding_t encoding;
+static bool encoding_set = false;
+pa_format_info *formats[1] = { NULL, };
+static char *stream_format = "raw";
+
 static sf_count_t (*readf_function)(SNDFILE *_sndfile, void *ptr, sf_count_t frames) = NULL;
 static sf_count_t (*writef_function)(SNDFILE *_sndfile, const void *ptr, sf_count_t frames) = NULL;
 
@@ -107,6 +124,7 @@ static pa_stream_flags_t flags = 0;
 
 static size_t latency = 0, process_time = 0;
 static int32_t latency_msec = 0, process_time_msec = 0;
+static int32_t offload_stream_bitrate = 8000;
 
 static bool raw = true;
 static int file_format = -1;
@@ -159,7 +177,8 @@ static void start_drain(void) {
 
         pa_stream_set_write_callback(stream, NULL, NULL);
 
-        if (!(o = pa_stream_drain(stream, stream_drain_complete, NULL))) {
+
+        if (!(o = pa_stream_drain(stream, stream_drain_complete, &offload_stream_bitrate))) {
             pa_log(_("pa_stream_drain(): %s"), pa_strerror(pa_context_errno(context)));
             quit(1);
             return;
@@ -319,7 +338,7 @@ static void stream_state_callback(pa_stream *s, void *userdata) {
 
             if (verbose) {
                 const pa_buffer_attr *a;
-                char cmt[PA_CHANNEL_MAP_SNPRINT_MAX], sst[PA_SAMPLE_SPEC_SNPRINT_MAX];
+                char cmt[PA_CHANNEL_MAP_SNPRINT_MAX], sst[PA_SAMPLE_SPEC_SNPRINT_MAX], fst[PA_FORMAT_INFO_SNPRINT_MAX];
 
                 pa_log(_("Stream successfully created."));
 
@@ -335,9 +354,14 @@ static void stream_state_callback(pa_stream *s, void *userdata) {
                     }
                 }
 
-                pa_log(_("Using sample spec '%s', channel map '%s'."),
-                        pa_sample_spec_snprint(sst, sizeof(sst), pa_stream_get_sample_spec(s)),
-                        pa_channel_map_snprint(cmt, sizeof(cmt), pa_stream_get_channel_map(s)));
+                if (!encoding_set) {
+                    pa_log(_("Using sample spec '%s', channel map '%s'."),
+                            pa_sample_spec_snprint(sst, sizeof(sst), pa_stream_get_sample_spec(s)),
+                            pa_channel_map_snprint(cmt, sizeof(cmt), pa_stream_get_channel_map(s)));
+                } else {
+                    pa_log(_("Using format '%s'."),
+                            pa_format_info_snprint(fst, sizeof(fst), pa_stream_get_format_info(s)));
+                }
 
                 pa_log(_("Connected to device %s (index: %u, suspended: %s)."),
                         pa_stream_get_device_name(s),
@@ -449,7 +473,12 @@ static void context_state_callback(pa_context *c, void *userdata) {
             if (verbose)
                 pa_log(_("Connection established.%s"), CLEAR_LINE);
 
-            if (!(stream = pa_stream_new_with_proplist(c, NULL, &sample_spec, &channel_map, proplist))) {
+            if (!encoding_set)
+                stream = pa_stream_new_with_proplist(c, NULL, &sample_spec, &channel_map, proplist);
+            else
+                stream = pa_stream_new_extended(c, NULL, formats, 1, proplist);
+
+            if (!stream) {
                 pa_log(_("pa_stream_new() failed: %s"), pa_strerror(pa_context_errno(c)));
                 goto fail;
             }
@@ -692,6 +721,8 @@ static void help(const char *argv0) {
              "      --channels=CHANNELS               The number of channels, 1 for mono, 2 for stereo\n"
              "                                        (defaults to 2)\n"
              "      --channel-map=CHANNELMAP          Channel map to use instead of the default\n"
+             "      --encoding=ENCODING               Encoding to use for non-PCM audio\n"
+             "      --stream-format=FLAG              Stream format flag to use for non-PCM audio\n"
              "      --fix-format                      Take the sample format from the sink/source the stream is\n"
              "                                        being connected to.\n"
              "      --fix-rate                        Take the sampling rate from the sink/source the stream is\n"
@@ -721,6 +752,8 @@ enum {
     ARG_SAMPLEFORMAT,
     ARG_CHANNELS,
     ARG_CHANNELMAP,
+    ARG_ENCODING,
+    ARG_STREAM_FORMAT,
     ARG_FIX_FORMAT,
     ARG_FIX_RATE,
     ARG_FIX_CHANNELS,
@@ -738,6 +771,125 @@ enum {
     ARG_MONITOR_STREAM,
 };
 
+static int skip_id3v2_header(FILE *file)
+{
+       char buffer[ID3V2_HEADER_SIZE + 1];
+       int ret, bytes_read;
+       uint32_t header_size;
+
+       /* we only need to parse ID3v2 header in order to skip
+        * the whole ID3v2 tag found at the beginning of the file.
+        *
+        * ID3v2 header has the following structure(v2.3.0):
+        *
+        * 1) file identifier
+        *      => 3 bytes long.
+        *      => has the value of ID3 for ID3v2 tag.
+        *
+        * 2) version
+        *      => 2 bytes long.
+        *
+        * 3) flags
+        *      => 1 byte long.
+        *
+        * 4) size
+        *      => 4 bytes long.
+        *      => the MSB of each byte is 0 so it needs to be ignored
+        *      when trying to parse the size.
+        *      => this field doesn't include the 10 bytes which make up
+        *      the ID3v2 header so a +10 needs to be added to this
+        *      field in order to get the correct position of the end
+        *      of the ID3v2 tag.
+        */
+
+       /* for now, we only support ID3v2 header found at the beginning
+        * of the file so we need to move file cursor to the beginning
+        * of the file
+        */
+       ret = fseek(file, 0, SEEK_SET);
+       if (ret < 0)
+               return ret;
+
+       buffer[ID3V2_HEADER_SIZE] = '\0';
+
+       /* read first ID3V2_HEADER_SIZE chunk */
+       bytes_read = fread(buffer, sizeof(char), ID3V2_HEADER_SIZE, file);
+
+       /* ID3v2 header is 10 bytes long
+        *
+        * if we can't read the 10 bytes then there's obviously no
+        * ID3v2 tag to skip
+        */
+       if (bytes_read != ID3V2_HEADER_SIZE)
+               return 0;
+
+       /* check if we're dealing with ID3v2 */
+       if (strncmp(buffer, "ID3", ID3V2_FILE_IDENTIFIER_SIZE) != 0)
+               return 0;
+
+       header_size = buffer[9];
+       header_size |= (buffer[8] << 7);
+       header_size |= (buffer[7] << 14);
+       header_size |= (buffer[6] << 21);
+
+       /* the header size field in ID3v2 header doesn't
+        * include the 10 bytes of which the header is made
+        * so we need to add them to get the correct position
+        */
+       return header_size + ID3V2_HEADER_SIZE;
+}
+
+void pa_parse_mpeg_header(FILE *file, int *sample_rate, int *num_channels, int *bit_rate) {
+       size_t read;
+       struct mp3_header header;
+       int offset;
+       int ver_idx, mp3_version, layer, bit_rate_idx, sample_rate_idx, channel_idx;
+
+       offset = skip_id3v2_header(file);
+       if (offset < 0) {
+               pa_log(_("Failed to get ID3 tag end position."));
+               return;
+       }
+
+       if (fseek(file, offset, SEEK_SET) < 0) {
+               pa_log(_("Unable to seek."));
+               return;
+       }
+
+       read = fread(&header, 1, sizeof(header), file);
+       if (read != sizeof(header)) {
+               pa_log(_("Unable to read header"));
+               return;
+       }
+
+       if ((header.sync & MP3_SYNC) != MP3_SYNC) {
+               pa_log(_("Error: Can't find sync word"));
+               return;
+       }
+       ver_idx = (header.sync >> 11) & 0x03;
+       mp3_version = ver_idx == 0 ? MPEG25 : ((ver_idx & 0x1) ? MPEG1 : MPEG2);
+       layer = 4 - ((header.sync >> 9) & 0x03);
+       bit_rate_idx = ((header.format1 >> 4) & 0x0f);
+       sample_rate_idx = ((header.format1 >> 2) & 0x03);
+       channel_idx = ((header.format2 >> 6) & 0x03);
+
+       if (sample_rate_idx == 3 || layer == 4 || bit_rate_idx == 15) {
+               pa_log(_("Can't find valid header"));
+               return;
+       }
+       *num_channels = (channel_idx == MONO ? 1 : 2);
+       *sample_rate = mp3_sample_rates[mp3_version][sample_rate_idx];
+       *bit_rate = (mp3_bit_rates[mp3_version][layer - 1][bit_rate_idx]) * 1000;
+
+
+       pa_log(_("num_channels %d, sample_rate %d, bit_rate %d"), *num_channels, *sample_rate, *bit_rate);
+
+       if (fseek(file, offset, SEEK_SET) < 0) {
+               pa_log(_("Failed to set cursor to offset"));
+               return;
+       }
+}
+
 int main(int argc, char *argv[]) {
     pa_mainloop* m = NULL;
     int ret = 1, c;
@@ -746,6 +898,7 @@ int main(int argc, char *argv[]) {
     const char *filename = NULL;
     /* type for pa_read/_write. passed as userdata to the callbacks */
     unsigned long type = 0;
+    FILE *fp = NULL;
 
     static const struct option long_options[] = {
         {"record",       0, NULL, 'r'},
@@ -762,6 +915,8 @@ int main(int argc, char *argv[]) {
         {"format",       1, NULL, ARG_SAMPLEFORMAT},
         {"channels",     1, NULL, ARG_CHANNELS},
         {"channel-map",  1, NULL, ARG_CHANNELMAP},
+        {"encoding",     1, NULL, ARG_ENCODING},
+        {"stream-format", 1, NULL, ARG_STREAM_FORMAT},
         {"fix-format",   0, NULL, ARG_FIX_FORMAT},
         {"fix-rate",     0, NULL, ARG_FIX_RATE},
         {"fix-channels", 0, NULL, ARG_FIX_CHANNELS},
@@ -908,6 +1063,24 @@ int main(int argc, char *argv[]) {
                 channel_map_set = true;
                 break;
 
+            case ARG_ENCODING:
+                if ((encoding = pa_encoding_from_string(optarg)) == PA_ENCODING_INVALID) {
+                    pa_log(_("Invalid encoding '%s'"), optarg);
+                    goto quit;
+                }
+
+                if (encoding == PA_ENCODING_PCM) {
+                    pa_log(_("The encoding parameter is only supported with non-PCM formats."));
+                    goto quit;
+                }
+
+                encoding_set = true;
+                break;
+
+            case ARG_STREAM_FORMAT:
+                stream_format = pa_locale_to_utf8(optarg);
+                break;
+
             case ARG_FIX_CHANNELS:
                 flags |= PA_STREAM_FIX_CHANNELS;
                 break;
@@ -1007,7 +1180,43 @@ int main(int argc, char *argv[]) {
         }
     }
 
-    if (!pa_sample_spec_valid(&sample_spec)) {
+    if (encoding_set && !raw) {
+        pa_log(_("Cannot set encoding for non-raw mode"));
+        goto quit;
+    }
+
+    if (encoding_set) {
+        if (optind+1 == argc) {
+            filename = argv[optind];
+            fp = fopen(filename, "r");
+            if (fp == NULL) {
+                    pa_log(_("file open fail"));
+                    goto quit;
+            }
+            switch (encoding) {
+            case PA_ENCODING_MPEG:
+                    pa_parse_mpeg_header(fp, &sample_spec.rate, &sample_spec.channels, &offload_stream_bitrate);
+                    break;
+            default:
+                    pa_log(_("using default sample_spec"));
+            }
+            fclose (fp);
+        } else if (optind+1 <= argc) {
+            pa_log(_("Too many arguments."));
+            goto quit;
+        }
+
+        formats[0] = pa_format_info_new();
+
+        formats[0]->encoding = encoding;
+        pa_format_info_set_prop_string(formats[0], "stream-format", stream_format);
+        pa_format_info_set_rate(formats[0], sample_spec.rate);
+        pa_format_info_set_channels(formats[0], sample_spec.channels);
+        if (!pa_format_info_valid(formats[0])) {
+            pa_log(_("Invalid format specification."));
+            goto quit;
+        }
+    } else if (!pa_sample_spec_valid(&sample_spec)) {
         pa_log(_("Invalid sample specification"));
         goto quit;
     }
@@ -1132,12 +1341,20 @@ int main(int argc, char *argv[]) {
     }
 
     if (verbose) {
-        char tss[PA_SAMPLE_SPEC_SNPRINT_MAX], tcm[PA_CHANNEL_MAP_SNPRINT_MAX];
+        if (!encoding_set) {
+            char tss[PA_SAMPLE_SPEC_SNPRINT_MAX], tcm[PA_CHANNEL_MAP_SNPRINT_MAX];
+
+            pa_log(_("Opening a %s stream with sample specification '%s' and channel map '%s'."),
+                    mode == RECORD ? _("recording") : _("playback"),
+                    pa_sample_spec_snprint(tss, sizeof(tss), &sample_spec),
+                    pa_channel_map_snprint(tcm, sizeof(tcm), &channel_map));
+        } else {
+            char tsf[PA_FORMAT_INFO_SNPRINT_MAX];
 
-        pa_log(_("Opening a %s stream with sample specification '%s' and channel map '%s'."),
-                mode == RECORD ? _("recording") : _("playback"),
-                pa_sample_spec_snprint(tss, sizeof(tss), &sample_spec),
-                pa_channel_map_snprint(tcm, sizeof(tcm), &channel_map));
+            pa_log(_("Opening a %s stream with format specification '%s'."),
+                    mode == RECORD ? _("recording") : _("playback"),
+                    pa_format_info_snprint(tsf, sizeof(tsf), formats[0]));
+        }
     }
 
     /* Fill in client name if none was set */
-- 
2.34.1

